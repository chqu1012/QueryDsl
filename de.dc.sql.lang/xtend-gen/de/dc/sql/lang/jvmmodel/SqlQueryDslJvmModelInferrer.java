/**
 * generated by Xtext 2.19.0
 */
package de.dc.sql.lang.jvmmodel;

import com.google.inject.Inject;
import de.dc.sql.lang.sqlQueryDsl.Model;
import de.dc.sql.lang.sqlQueryDsl.Query;
import java.util.Arrays;
import java.util.Scanner;
import java.util.function.Consumer;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtend2.lib.StringConcatenationClient;
import org.eclipse.xtext.common.types.JvmFormalParameter;
import org.eclipse.xtext.common.types.JvmGenericType;
import org.eclipse.xtext.common.types.JvmMember;
import org.eclipse.xtext.common.types.JvmOperation;
import org.eclipse.xtext.common.types.JvmVisibility;
import org.eclipse.xtext.common.types.TypesFactory;
import org.eclipse.xtext.xbase.jvmmodel.AbstractModelInferrer;
import org.eclipse.xtext.xbase.jvmmodel.IJvmDeclaredTypeAcceptor;
import org.eclipse.xtext.xbase.jvmmodel.JvmTypesBuilder;
import org.eclipse.xtext.xbase.lib.Extension;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.Procedures.Procedure1;

@SuppressWarnings("all")
public class SqlQueryDslJvmModelInferrer extends AbstractModelInferrer {
  @Inject
  private TypesFactory typesFactory;
  
  @Inject
  @Extension
  private JvmTypesBuilder _jvmTypesBuilder;
  
  protected void _infer(final Model element, final IJvmDeclaredTypeAcceptor acceptor, final boolean isPreIndexingPhase) {
    String _package = element.getPackage();
    String _plus = (_package + ".");
    String _name = element.getName();
    String _plus_1 = (_plus + _name);
    final Procedure1<JvmGenericType> _function = (JvmGenericType it) -> {
      EList<Query> _queries = element.getQueries();
      for (final Query query : _queries) {
        {
          final JvmOperation jvmOperation = this.typesFactory.createJvmOperation();
          jvmOperation.setSimpleName(query.getName());
          jvmOperation.setReturnType(this._typeReferenceBuilder.typeRef(String.class));
          jvmOperation.setStatic(true);
          jvmOperation.setVisibility(JvmVisibility.PUBLIC);
          final Consumer<JvmFormalParameter> _function_1 = (JvmFormalParameter e) -> {
            EList<JvmFormalParameter> _parameters = jvmOperation.getParameters();
            JvmFormalParameter _parameter = this._jvmTypesBuilder.toParameter(e, e.getName(), e.getParameterType());
            this._jvmTypesBuilder.<JvmFormalParameter>operator_add(_parameters, _parameter);
          };
          IterableExtensions.<JvmFormalParameter>toList(query.getParameters()).forEach(_function_1);
          StringConcatenationClient _client = new StringConcatenationClient() {
            @Override
            protected void appendTo(StringConcatenationClient.TargetStringConcatenation _builder) {
              String _content = SqlQueryDslJvmModelInferrer.this.content(query.getStatement());
              _builder.append(_content);
              _builder.newLineIfNotEmpty();
              _builder.append("String content = sb.toString();");
              _builder.newLine();
              {
                EList<JvmFormalParameter> _parameters = query.getParameters();
                for(final JvmFormalParameter p : _parameters) {
                  _builder.append("content = content.replaceAll(\"<");
                  String _name = p.getName();
                  _builder.append(_name);
                  _builder.append(">\", String.valueOf(");
                  String _name_1 = p.getName();
                  _builder.append(_name_1);
                  _builder.append("));");
                  _builder.newLineIfNotEmpty();
                }
              }
              _builder.append("return content.trim();");
              _builder.newLine();
            }
          };
          this._jvmTypesBuilder.setBody(jvmOperation, _client);
          EList<JvmMember> _members = it.getMembers();
          this._jvmTypesBuilder.<JvmOperation>operator_add(_members, jvmOperation);
        }
      }
    };
    acceptor.<JvmGenericType>accept(this._jvmTypesBuilder.toClass(element, _plus_1), _function);
  }
  
  public String content(final String source) {
    String _xblockexpression = null;
    {
      final Scanner scanner = new Scanner(source);
      String line = null;
      final StringBuilder stringBuilder = new StringBuilder();
      final String ls = System.getProperty("line.separator");
      stringBuilder.append(("StringBuilder sb = new StringBuilder();" + ls));
      while (scanner.hasNextLine()) {
        {
          line = scanner.nextLine().trim();
          stringBuilder.append((((("sb.append(\"" + line) + " ") + "\");") + ls));
        }
      }
      scanner.close();
      String content = stringBuilder.toString();
      content = content.replaceAll("```", "");
      _xblockexpression = content;
    }
    return _xblockexpression;
  }
  
  public void infer(final EObject element, final IJvmDeclaredTypeAcceptor acceptor, final boolean isPreIndexingPhase) {
    if (element instanceof Model) {
      _infer((Model)element, acceptor, isPreIndexingPhase);
      return;
    } else if (element != null) {
      _infer(element, acceptor, isPreIndexingPhase);
      return;
    } else {
      throw new IllegalArgumentException("Unhandled parameter types: " +
        Arrays.<Object>asList(element, acceptor, isPreIndexingPhase).toString());
    }
  }
}
